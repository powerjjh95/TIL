# Sorting Alogorithm

<aside>
💡 정렬의 종류

</aside>

| 안정 정렬  | 불안정 정렬 |
| ------ | ------ |
| 버블 정렬  | 선택 정렬  |
| 카운팅 정렬 | 퀵 정렬   |
| 삽입 정렬  |        |
| 병합 정렬  |        |

---

## 1️⃣ 버블 정렬 🧼

> 자료를 특정 기준에 의해 작은 값부터 큰 값 혹은 그 반대의 순서로 자리를 바꿔가며 재배열

```python
# 버블 정렬 코드
arr = [2, 4, 1, 3]  # 정렬하고자 하는 리스트의 길이가 4니까?

for i in range(len(arr)-1, 0, -1):  # 총 3회 시행, 
    for j in range(i): # 각 시행 횟수 안에서, 3 2 1 번씩 비교 할것 
        if arr[j] > arr[j+1]: # 내가 오른쪽 녀석보다 크다면?
            arr[j], arr[j+1] = arr[j+1], arr[j]  # 자리를 바꾼다!

print(arr)
```

```python
# 버블 정렬 코드

```



원본 리스트가 [2, 4, 1, 3]라고 한다면, 해당 리스트를 정렬하려면 다음과 같은 절차를 거칩니다.

우선, **1회**의 시행 안에서 **3번**의 비교를 합니다.

⇒ 리스트 길이가 4고, 처음은 3번을 비교해야 하니까요!

<첫 번째 시행>

1. `2`와 `4`를 비교한 결과, `2`가 `4`보다 작으므로 위치를 바꾸지 않고 넘어갑니다.
2. `4`와 `1`을 비교한 결과, `4`가 `1`보다 크므로 자리를 바꾸고 [2, 1, 4, 3]이 됩니다.
3. 다시 `4`와 `3`을 비교한 결과, `4`가 `3`보다 크므로 자리를 바꾸고 [2, 1, 3, 4]가 됩니다.

첫 번째 시행의 결과 제일 뒤의 4는 가장 큰 값으로 확정되었습니다. ⇒ [2, 1, 3, **4**]

<두 번째 시행>

4는 이미 확정이고, 나머지 앞의 3개의 숫자를 비교하기 위해 2번 비교합니다.

[2, 1, 3, **4**] 중 2, 1, 3에 대하여 앞의 논리를 반복합니다.

시행이 거듭될수록 하나씩 하나씩 뒤에 확정된 값이 쌓이게 됩니다.

<aside>
💡 2차원 리스트를 기준점을 잡고 버블 정렬을 할 수 없을까?

</aside>

```python
a = [[4, 4, 16], [6, 1, 6], [4, 3, 12], [1, 12, 12], [5, 4, 20], [2, 3, 6], [3, 4, 12]]

def bubble_sort(idx): # 기준점을 잡고 할 수 있습니다.

    for i in range(len(a)-1, 0, -1):
        for j in range(i):
            if a[j][idx] > a[j+1][idx]: # 기준으로 비교하되,
                a[j], a[j+1] = a[j+1], a[j] # 그 안의 객체가 바뀌는 것!

bubble_sort(1) # 두 번째 인덱스를 기준으로 정렬합니다.

# key를 활용해 다음과 같이 정렬해도 됩니다.
sorted_a = sorted(a, key=lambda x: x[1])
print(sorted_a)
```

---

## 2️⃣ 카운팅 정렬 ⏳

> 주어진 리스트의 `값`의 범위가 작을 때 유용합니다.

⇒ 카드 같은 것들 세기 좋습니다. (그래봤자 범위가 1~ 9인 그런 문제들)

```python
# 카운팅 정렬 코드
nums = [4, 4, 2, 3, 5, 5, 1, 1, 5]

count = [0] * (max(nums) + 1)  # 갯수 세는 리스트
sorted_nums = [0] * len(nums)  # 정렬된 리스트의 원형 틀

for num in nums:  # 일단 몇개씩 있는지 카운트
    count[num] += 1

for i in range(1, len(count)):  # 누적합
    count[i] = count[i] + count[i-1]

for j in range(len(nums)-1, -1, -1):  # 뒤의 자리부터 뽑아서,
    sorted_nums[count[nums[j]]-1] = nums[j] # 5가 튀어나오면 5의 위치에 뒤부터 삽입.
    count[nums[j]] -= 1  # 위치 인덱스 하나 깎음

print(sorted_nums)
```

**아이디어는 다음과 같습니다.**

nums 리스트에서 1이 `두 개`, 2가 `한 개`… 이렇게 하나씩 세서 정리를 할건데, nums 리스트에서 최댓값을 구해보면 현재는 `5`입니다.

그러면, 6칸짜리 정리용 리스트만 만들어 두면 nums에서 하나씩 뽑아서 차곡차곡 정리할 수 있습니다.

```python
# 이렇게 만드려고 하는거죠!
# 인덱스 기준으로 1이 두개, 2가 한개, 3이 한개, 4가 두개, 5가 세개
count = [0, 2, 1, 1, 2, 3]

# 그래서 count 기본 틀을 만들 때는 5가 들어가려면 6칸이 필요하므로 1을 더해서 만듭니다.
count = [0] * (max(nums) + 1)
```

<aside>
💡 그러면 누적합은 뭐하러 하는걸까?

</aside>

사실, 아까 count 배열을 차곡차곡 완성했을 때 정렬은 끝나긴 했습니다.

```python
nums = [4, 4, 2, 3, 5, 5, 1, 1, 5]

count = [0] * (max(nums) + 1)

for num in nums: # 차곡차곡
    count[num] += 1

print(count)

sorted_list = []  # 빈 틀

for idx, n in enumerate(count): # 하나씩 뽑으면서
    for _ in range(n):
        sorted_list.append(idx)  # 갯수만큼 순서대로 append!

print(sorted_list) # [1, 1, 2, 3, 4, 4, 5, 5, 5]
```

어차피 인덱스 기준으로 1이 두개, 2가 한개, 3이 한개, 4가 두개, 5가 세개라는걸 알기만 한다면 내가 현재 가지고 있는 `count = [0, 2, 1, 1, 2, 3]` 리스트에서 0은 없으니까 버리고 앞쪽부터 보면서 순서대로 붙인다고 생각해보면,

빈 `sorted_list = [ ]`를 하나 파두고, 1을 두번 append 해서 `sorted_list = [1, 1]`을 만들고 그다음 2를 1번, 3을 1번… 이런식으로 append한 결과는 정렬되어 있을 거니까요!

> 그러면 누적합은 왜 하는데? ⇒ **안정 정렬** 결과를 얻기 위함입니다.

사실, 지금은 원소가 1, 2 같은 숫자니 안 보일지 몰라도 아까 `nums = [4, 4, 2, 3, 5, 5, 1, 1, 5]` 에서 첫 번째 4는 사실 `4-A` 였고, 두 번째 4는 `4-B`라는 다른 존재였다고 생각해보면, 위의 방식으로는 반드시 `4-A`뒤에 `4-B`가 온다고 보장할 수 없습니다.

만약 위의 2차원 버블정렬처럼 리스트의 원소가 (4, ‘A’), (4, ‘b’)였다면 더 확연하게 드러나겠죠.

일단 누적합 결과부터 보면, 다음과 같습니다.

```python
# 원래 숫자들
nums = [4, 4, 2, 3, 5, 5, 1, 1, 5]

# 누적합 전의 카운트 리스트
count = [0, 2, 1, 1, 2, 3]

**# 누적합 결과 => 5번 인덱스의 6은 무슨 의미일까?**
count = [0, 2, 3, 4, 6, 9]

# 빈 틀
sorted_nums = [0, 0, 0, 0, 0, 0, 0, 0, 0]

# 되어야 할 결과 => 실제로 6번에 4라는 숫자가 있다.
sorted_nums = [1, 1, 2, 3, 4, 4, 5, 5, 5]
```

`누적합 결과`의 5번 인덱스의 **`6`**은 무슨 의미냐면,

5번 인덱스, 즉 4라는 숫자는 **되어야 할 결과** 기준으로 **여섯 번째**까지를 **차지해야 한다**는 뜻입니다.

그러니 **안정 정렬**을 위해서는, `원래 숫자들`의 **뒤에서부터 뽑으면서** (이러면 5, 1, 1, 5, … 순으로 나오겠죠?) 차지해야 하는 영역의 오른쪽부터 거꾸로 채워 나가면 됩니다.

곧, `원래 숫자들에서` **5**를 뽑은 후, `누적합 결과`에서 5번째 인덱스를 보니 `9`라는 값이 있고

`9`라는 값은 **5**가 `되어야 할 결과`기준으로 9번째(인덱스로는 8)에 있다는 뜻이니 과정을 살펴보면

다음과 같습니다.

```python
# 5부터 뽑고, 9번째 위치에(인덱스로는 8이니 -1) 5를 할당
# 이후에 그다음 5는 8번째 위치에 넣어야 하니까 count 배열에서 한 개 깎기
sorted_nums[9 - 1] = 5
count[5] -= 1

# 결과
sorted_nums = [0, 0, 0, 0, 0, 0, 0, 0, 5]
```

그런데 이러면 사실 5는 현재 3개가 있으므로 나중에 쓰고나서 깎은 후에는 count 배열의 모습은 다음과 같을 겁니다.

```python
count = [-, -, -, -, -, 6]
```

그런데 사실 저 숫자는 이제 오른쪽 어디에 넣느냐만 나타낼 뿐 6으로 남겨져 있어도 전혀 상관 없습니다.

그래서 뒤에서부터 삽입하는 코드는 다음과 같습니다.

```python
for j in range(len(nums)-1, -1, -1):  # 뒤의 자리부터 뽑아서,
    sorted_nums[count[nums[j]]-1] = nums[j] # 5가 튀어나오면 5의 위치에 뒤부터 삽입.
    count[nums[j]] -= 1  # 위치 인덱스 하나 깎음
```

해당 프로세스를 모두 돌고나면 정렬이 완료됩니다.
